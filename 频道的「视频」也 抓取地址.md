1、打开 YouTube 频道的【视频】页面；
2、按下快捷键打开控制台：`Command + Option + J`
3、复制以下脚本到控制台并运行；

```js
// 适配频道“视频”页：自动滚动 + 仅抓 /watch 视频 + 按 v 去重
// ✅ RANGE 基于“未过滤的 /watch 原始顺序”
// ✅ IGNORE_INDEXES 也是“原始顺序序号”
// ✅ 过滤（会员/时长/标题）在 RANGE + IGNORE 之后生效
// + 复制结果
(async () => {
  const sleep = ms => new Promise(r => setTimeout(r, ms));

  // =========================
  // ✅ 可配置（按需修改）
  // =========================
  const MIN_SECONDS   = 0;         // 只保留 >= 指定秒数的视频（0 表示不过滤）
                                   // 若想更接近“常规视频”，可设为 60
  const WAIT_MS       = 1200;      // 每轮滚动等待时间
  const IDLE_ROUNDS   = 4;         // 连续几轮无新增就停止

  // ✅ 范围抓取（1-based，包含端点）
  // 注意：序号是“未过滤的 /watch 原始顺序”
  const RANGE = null;
  // const RANGE = { start: 1, end: 20 };
  // const RANGE = { start: 21, end: 40 };

  // ✅ 忽略原始序号（1-based）
  // 例：RANGE=1-20，IGNORE=[3,5] => 原始第3、第5个不抓
  const IGNORE_INDEXES = [];
  // const IGNORE_INDEXES = [3, 5];

  // ✅ 跳过会员专享视频（在 RANGE + IGNORE 之后生效）
  const SKIP_MEMBERS_ONLY = true;

  // ✅ 标题过滤（在 RANGE + IGNORE 之后生效）
  // 1) 白名单：有这些关键字才抓（OR 关系）
  const TITLE_INCLUDE_KEYWORDS = [];
  // const TITLE_INCLUDE_KEYWORDS = ["aaa", "bbb"];

  // 2) 黑名单：包含这些关键字就不抓（OR 关系）
  const TITLE_EXCLUDE_KEYWORDS = [];
  // const TITLE_EXCLUDE_KEYWORDS = ["ccc", "ddd"];

  // ✅ 是否区分大小写（默认不区分）
  const TITLE_CASE_SENSITIVE = false;
  
  // ✅ 是否在输出中包含标题（用 Tab 分隔，便于粘贴到表格）
  // false = 只输出 URL（默认）
  // true  = URL<TAB>标题（一行一条）
  const OUTPUT_WITH_TITLE = false;

  // =========================
  // UI Toast
  // =========================
  const toast = (msg) => {
    let t = document.getElementById('__yt_videos_toast__');
    if (!t) {
      t = document.createElement('div');
      t.id = '__yt_videos_toast__';
      Object.assign(t.style, {
        position: 'fixed', right: '16px', bottom: '16px', zIndex: 2147483647,
        maxWidth: '60vw', padding: '10px 14px', borderRadius: '8px',
        background: 'rgba(0,0,0,.85)', color: '#fff', fontSize: '14px', lineHeight: '1.4'
      });
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.display = 'block';
    clearTimeout(t.__hidetimer);
    t.__hidetimer = setTimeout(() => (t.style.display = 'none'), 3000);
  };

  // =========================
  // Duration parser
  // =========================
  const parseDuration = (txt) => {
    if (!txt) return null;
    const s = txt.trim().replace(/\s/g, '');
    if (!/^\d{1,2}:\d{2}(:\d{2})?$/.test(s)) return null;
    const parts = s.split(':').map(n => parseInt(n, 10));
    if (parts.length === 2) return parts[0]*60 + parts[1];
    if (parts.length === 3) return parts[0]*3600 + parts[1]*60 + parts[2];
    return null;
  };

  // =========================
  // Members-only detector (DOM-based)
  // =========================
  const isMembersOnly = (card) => {
    const keywords = [
      'Members only',
      'Member-only',
      '会员专享',
      '仅限会员',
      '会员限定',
    ];

    const badgeSelectors = [
      'ytd-badge-supported-renderer',
      'ytd-thumbnail-overlay-badge-renderer',
      '#badges ytd-badge-supported-renderer',
      '#badges yt-formatted-string',
    ];

    for (const sel of badgeSelectors) {
      const nodes = card.querySelectorAll(sel);
      for (const node of nodes) {
        const txt = (node.textContent || '').trim();
        if (txt && keywords.some(k => txt.includes(k))) return true;
      }
    }

    const ariaNodes = card.querySelectorAll('[aria-label]');
    for (const node of ariaNodes) {
      const a = (node.getAttribute('aria-label') || '').trim();
      if (a && keywords.some(k => a.includes(k))) return true;
    }

    return false;
  };

  // =========================
  // Title helpers
  // =========================
  const normalize = (s) => {
    const t = (s || '').trim();
    return TITLE_CASE_SENSITIVE ? t : t.toLowerCase();
  };

  const cleanKeywords = (arr) =>
    (Array.isArray(arr) ? arr : [])
      .map(k => (k ?? '').toString().trim())
      .filter(Boolean);

  const includeKeys = cleanKeywords(TITLE_INCLUDE_KEYWORDS).map(normalize);
  const excludeKeys = cleanKeywords(TITLE_EXCLUDE_KEYWORDS).map(normalize);

  const matchesAny = (title, keys) => {
    if (!keys.length) return false;
    const t = normalize(title);
    if (!t) return false;
    return keys.some(k => t.includes(k));
  };

  // =========================
  // Read one card (NO FILTERS here)
  // 只要是 /watch 就收进“基础顺序池”
  // =========================
  const readCardInfo = (card) => {
    const a =
      card.querySelector('a#video-title-link[href]') ||
      card.querySelector('a#thumbnail[href]');
    if (!a) return null;

    const hrefRaw = a.href || a.getAttribute('href');
    if (!hrefRaw) return null;

    const urlObj = new URL(hrefRaw, 'https://www.youtube.com');

    // ✅ 基础顺序只以 /watch 为准
    if (urlObj.pathname !== '/watch') return null;

    const v = urlObj.searchParams.get('v');
    if (!v) return null;

    // 标题（尽量稳地取）
    const titleText =
      (card.querySelector('a#video-title-link')?.textContent) ||
      (card.querySelector('#video-title')?.textContent) ||
      (a.textContent) ||
      '';

    // 可见时长角标（可能为空）
    let seconds = null;
    const badge = card.querySelector('ytd-thumbnail-overlay-time-status-renderer span');
    if (badge) seconds = parseDuration(badge.textContent);

    const membersOnly = isMembersOnly(card);

    return {
      id: v,
      url: `https://www.youtube.com/watch?v=${v}`,
      title: titleText.trim(),
      seconds,
      membersOnly,
    };
  };

  // 收集当前已渲染的全部 /watch 卡片
  const collectBase = () => {
    const cards = document.querySelectorAll('ytd-rich-grid-media');
    const results = [];

    cards.forEach(card => {
      const info = readCardInfo(card);
      if (info) results.push(info);
    });

    return results;
  };

  // =========================
  // Continuation button (old layout)
  // =========================
  const tryClickContinuation = () => {
    const btn =
      document.querySelector('ytd-continuation-item-renderer a[href], ytd-button-renderer[is="paper-button"] a[href]');
    if (btn) { btn.click(); return true; }
    return false;
  };

  // =========================
  // Main loop
  // =========================
  const rangeMsg = RANGE ? `基础范围 ${RANGE.start}-${RANGE.end}` : '全量';
  const ignoreMsg = IGNORE_INDEXES.length ? `，忽略 ${IGNORE_INDEXES.join(',')}` : '';
  const titleMsg =
    (includeKeys.length || excludeKeys.length)
      ? `，标题过滤${includeKeys.length ? ' +include' : ''}${excludeKeys.length ? ' +exclude' : ''}`
      : '';

  toast(`⬇️ 正在加载与收集频道视频（${rangeMsg}${ignoreMsg}${titleMsg}）…`);

  const map = new Map();        // id -> info
  const orderedIds = [];        // ✅ “未过滤的 /watch 原始顺序”
  let idle = 0, last = 0;
  let reachedOnce = false;

  for (let i = 0; i < 9999; i++) {
    window.scrollTo(0, document.documentElement.scrollHeight);
    tryClickContinuation();
    await sleep(WAIT_MS);

    const items = collectBase();
    items.forEach(info => {
      if (!map.has(info.id)) orderedIds.push(info.id);
      map.set(info.id, info);
    });

    const found = orderedIds.length;

    if (found === last) idle++;
    else { idle = 0; last = found; }

    toast(`已发现 ${found} 个 /watch 视频（未过滤顺序）…`);

    // ✅ 达到基础范围 end 后，多确认一轮再停
    if (RANGE && found >= RANGE.end) {
      if (reachedOnce) break;
      reachedOnce = true;
    } else {
      reachedOnce = false;
    }

    if (idle >= IDLE_ROUNDS) break;
  }

  // =========================
  // Build base ordered list (with original index)
  // =========================
  const baseOrdered = orderedIds
    .map((id, idx) => {
      const info = map.get(id);
      if (!info) return null;
      return { ...info, __index: idx + 1 }; // ✅ 原始序号
    })
    .filter(Boolean);

  const ignoreSet = new Set(IGNORE_INDEXES);

  // ✅ 先按 RANGE 选原始序号区间
  const baseRange = RANGE
    ? baseOrdered.filter(x => x.__index >= RANGE.start && x.__index <= RANGE.end)
    : baseOrdered;

  // ✅ 再按 IGNORE_INDEXES 剔除原始序号
  const baseAfterIgnore = ignoreSet.size
    ? baseRange.filter(x => !ignoreSet.has(x.__index))
    : baseRange;

  // ✅ 最后应用过滤（范围+忽略之后）
  const finalInfos = baseAfterIgnore.filter(info => {
    // 会员
    if (SKIP_MEMBERS_ONLY && info.membersOnly) return false;

    // 时长
    if (MIN_SECONDS > 0) {
      if (info.seconds == null || info.seconds < MIN_SECONDS) return false;
    }

    // 标题白名单（有指定关键字的才抓）
    if (includeKeys.length) {
      // 标题不存在则视为不匹配
      if (!matchesAny(info.title, includeKeys)) return false;
    }

    // 标题黑名单（有指定关键字的不抓）
    if (excludeKeys.length) {
      if (matchesAny(info.title, excludeKeys)) return false;
    }

    return true;
  });
  
  const finalList = finalInfos.map(x => {
    if (OUTPUT_WITH_TITLE) {
      // URL \t Title → 粘贴到 Google 表格自动两列
      return `${x.url}\t${x.title}`;
    }
    return x.url;
  });
  
  const text = finalList.join('\n');

  // =========================
  // Copy
  // =========================
  let copied = false;
  try { await navigator.clipboard.writeText(text); copied = true; } catch (_) {}
  if (!copied && typeof copy === 'function') {
    try { copy(text); copied = true; } catch (_) {}
  }

  console.clear();
  console.log(text);

  if (RANGE || IGNORE_INDEXES.length || includeKeys.length || excludeKeys.length) {
    const baseCount = baseRange.length;
    const afterIgnoreCount = baseAfterIgnore.length;

    toast(
      `✅ 完成：${rangeMsg}${ignoreMsg}` +
      `${includeKeys.length ? `，include=${TITLE_INCLUDE_KEYWORDS.join('|')}` : ''}` +
      `${excludeKeys.length ? `，exclude=${TITLE_EXCLUDE_KEYWORDS.join('|')}` : ''}` +
      `，范围内 ${baseCount} 条 → 忽略后 ${afterIgnoreCount} 条 → 过滤后输出 ${finalList.length} 条` +
      `${copied ? '（已复制）' : '。复制失败，请从控制台复制'}`
    );
  } else {
    toast(`✅ 完成：共 ${finalList.length} 个链接${copied ? '（已复制）' : '。复制失败，请从控制台复制'}`);
  }
})();

```


